@name all_cool_v2
@inputs W A S D Mouse1 Mouse2 Shift Space RPM CHASSIS:entity
@outputs Gear Throttle Brake Constant Damping Red Speed
@persist SLAVE:entity [TURN_RATE TURN_ANGLE TURN] Speed C Triggered LastGear Direction GearChanged State:string
@model models/sprops/rectangles/size_2_5/rect_18x18x3.mdl

## Current Issues: Pressing reverse, then braking, then swapping to forwards and letting go of the brakes will result in you locking to ReversingGear - 1

# Set to the engines Redline value
Redline = 5860

# Adjusts the strength of the brakes
BrakingForce = 100

# Adjust if suspension is too bouncy or too tight
Constant = 50000
Damping = 500

# 9 basically just sets it to max on any gearbox
# This means it will always set to final gear, and you can avoid it
ReversingGear = 8



############
# THE CODE #
############

function number throttle(Inputs:array) {
    Throttle = 0
    foreach(K:number, Input:number = Inputs) {
        if (Input == 1) {
            Throttle = 100
            return Throttle
        }
    }
    return Throttle
}

function number autoReverse(ForwardInput:number, BackwardInput:number, Gear:number, ReversingGear:number, Direction:number) {
    if (ForwardInput == 1 && Direction >= 0) {
        if (Gear == ReversingGear || Gear == 0) {
            Gear = 1
        }
    }
    if (BackwardInput == 1) {
        Gear = ReversingGear
    }
    return Gear
}

function number getDirection(ForwardInput:number, BackwardInput:number) {
    if (ForwardInput == 1) {
        Direction = 1
        return Direction
    }
    
    if (BackwardInput == 1) {
        Direction = -1
    }
    return Direction
}

function number brakeWithForce(Input:number, BrakingForce:number, Brake:number) {
    if (Input == 1) {
        return BrakingForce
    }
    return Brake
}

# Redline Light (Actually the Power RPM Limit but Redline sounds cooler)
function number redLineAlert(RPM:number, Redline:number) {
    if (RPM >= Redline) {
        MaxRGB = 255
        return MaxRGB
    }
    else {
        MinRGB = 0
        return MinRGB
    }
}

function number gearBoundCheck(Gear:number, Bound:number, Correction:number) {
    if (Gear == Bound) {
        Gear += Correction
    }
    return Gear
}

function number hasGearInputReleased(GearUp:number, GearDown:number, GearChanged) {
    if (GearUp == 0 && GearDown == 0) {
        GearChanged = 0
    }
    return GearChanged
}

function number adjustGear(GearUp:number, GearDown:number, Gear:number, GearChanged:number, ReversingGear:number) {
    
    if (GearUp == 1 && GearDown == 1) {
        return Gear
    }
    
    if (GearUp == 1 && GearChanged == 0) {
        Gear += 1
    }
    
    if (GearDown == 1 && GearChanged == 0) {
        Gear -= 1
    }
    
    return Gear
}

function number setAng(A:number, D:number, B:number,TURN_ANGLE:number,TURN:number,TURN_RATE:number) {
    if (dupefinished()) {reset()}
    
    B = round(toUnit("km/h",CHASSIS:vel():length()))

    if(B >= 20)  {
        TURN_ANGLE = 25
    }
    else
    {
        TURN_ANGLE = 45
    }
    
    if (first())    {
        interval(20)

        SLAVE = entity()
    } elseif (clk())    {
        interval(20)
    
        if (!SLAVE:isPlayerHolding())    {
            TURN += clamp((A-D)*TURN_ANGLE - TURN, -TURN_RATE, TURN_RATE)
            SLAVE:setAng( CHASSIS:toWorld(ang(0, TURN, 0)) )
            SLAVE:propFreeze(1)
        }
    }
    
    return TURN
}


#############
# THE LOGIC #
#############

# Speedometer
Speed = round((toUnit("km/h",CHASSIS:vel():length())) / 1.609)

# Resets values so they can be released
Throttle = 0
Brake = 0

# Enables turning when holding A or D
TURN_RATE = 5
TURN = setAng(A,D,Speed,TURN_ANGLE,TURN,TURN_RATE)

# Soft Brakes
BrakingForce = 5
Brake = brakeWithForce(Space, BrakingForce, Brake)

# Hard Brakes
BrakingForce = 50
Brake = brakeWithForce(Shift, BrakingForce, Brake)

switch (State) {
    
    case "Driving",
        
        # If brakes are pressed, break and move to the Braking state
        if (Brake != 0) {
            State = "Braking"
            break   
        }
        
        # Checks for Forwards/Backwards input
        Gear = autoReverse(W,S,Gear,ReversingGear,Direction)
        
        # Turns on the light when the RPM reaches the Redline
        Red = redLineAlert(RPM,Redline)
        
        # Sets Throttle to 100 (The max) if Forward or Backwards is pressed
        Throttle = throttle(array(W,S))
        
        break
        
    case "Braking",

        if (Speed < 1) {
            Gear = 0
            Direction = 0
            State = "Neutral"
            break
        }

        if (Brake == 0) {
            State = "Driving"
            break
        }

        break
        
    case "Neutral",
        
        if (Brake > 0) {
            break
        }

        Throttle = throttle(array(W,S))

        Gear = autoReverse(W,S,Gear,ReversingGear,Direction)
        
        if (Gear > 0) {
            State = "Driving"
            break
        }
        
        break
        
    default,

        State = "Neutral"
}

# Inputs for changing gears

# Checks if the input for changing gears has been released
GearChanged = hasGearInputReleased(Mouse1, Mouse2, GearChanged)

# Saves the current gear
PreviousGear = Gear

# Updates the gear (If GearChanged == 0, which it only will if the input has been released - prevents holding input for beeeg changes)
Gear = adjustGear(Mouse1, Mouse2, Gear, GearChanged, ReversingGear)

# Checks if the input has been pressed again
if (PreviousGear != Gear) {
    GearChanged = 1
}

# Boundary Checks for Gears to ensure they stay within them
switch (Direction) {
    
    # Reversing
    case -1,
        Gear = ReversingGear
        break
        
    # Forwards
    case 1,
        Correction = 1
        Bound = 0
        Gear = gearBoundCheck(Gear, Bound, Correction)
        
    # Forwards / Neutral (Reversing is locked to a single gear)
    default,
    
        Correction = -1
        Bound = ReversingGear
        Gear = gearBoundCheck(Gear, Bound, Correction)
        
        # Prevents going lower while in Neutral, doesn't prevent going higher
        Correction = 1
        Bound = -1
        Gear = gearBoundCheck(Gear, Bound, Correction)

}

# Gets the current directional input (Forwards / Backwards)
Direction = getDirection(W,S)
